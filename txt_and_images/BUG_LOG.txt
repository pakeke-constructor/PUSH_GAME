[[[[[]]]]]
[[[[[]]]]]
[[[[[]]]]]
[[[[[]]]]]
[[[[[]]]]]

This file serves as an archive for old bugs.

If a bug arises again, check here to ensure that it hasn't been solved previously

[[[[[]]]]]
[[[[[]]]]]
[[[[[]]]]]
[[[[[]]]]]
[[[[[]]]]]










Error: src/misc/behaviour/movebehaviours/orbit.lua:38: 'struct 263' has no member named 'pos'
stack traceback:
        [string "boot.lua"]:777: in function '__index'
        src/misc/behaviour/movebehaviours/orbit.lua:38: in function 'update'
        src/systems/MoveBehaviourSys.lua:526: in function <src/systems/MoveBehaviourSys.lua:517>
        libs/Cyan/cyan.lua:69: in function 'call'
        src/misc/unique/gamestate.lua:19: in function 'update'
        [string "boot.lua"]:612: in function <[string "boot.lua"]:594>
        [C]: in function 'xpcall'
ORIGIN OF THE BUG AND SOLUTION:
pretty much all MoveBehaviour Systems use `ent.behaviour.move.target` as a vec3 value.
LOCKON, however, uses `.target` as a `Entity` type to track ents. We can fix this
by changing `target` to a vec3 quantity, and allocating an extra field to store
the entity. (This way we can use `cexists(ent)` to check whether the ent that is
being followed still exists.)

FOR FUTURE TODO ::::
DOCUMENT THE MoveBehaviourSys FIELDS WAYYYY BETTER!!!! BE MORE RIGOUROUS, and be
consistent. Ensure to do background checks on data passed into each moveBehaviour,
and just be super rigorous when switching moveBehaviours.
(Add a tonne of assertions into ccall("setMoveBehaviour", ... ) )

===> HAVE SPLIT THEM UP, NEED TO DO MORE ASSERTIONS AND DOCUMENTATION
Should be fixed as of 16/02/2021


















Bug2:
in `RAND` moveBehaviour, ents are being stupid and walking into walls.
This is because, although Tools.isIntersect() works fine, the interior walls
dont have a physics body!!!! So if a random position is selected inside a walled
off area, there is a chance that the intersection function will just miss the
intersections by a very slight amount
possible solutions:
- Create own intersection function
- Dont use physics intersection to select a random position, and instead have
    MoveBehaviourSys subscribe to the `collide` callback

!!! ON SECOND THOUGHT, This probably isnt the reason!
===> The reason is probably due to entities initializing their physics path
BEFORE the map has been fully initialized. So their path IS valid, but not when the 
whole map has finished generating


























Error: src/misc/behaviour/movebehaviours/base.lua:37: attempt to perform arithmetic on local 'pos_x' (a nil value)
stack traceback:
        [string "boot.lua"]:777: in function '__sub'
        src/misc/behaviour/movebehaviours/base.lua:37: in function 'updateGotoTarget'
        src/misc/behaviour/movebehaviours/rand.lua:18: in function 'update'
        src/systems/MoveBehaviourSys.lua:528: in function <src/systems/MoveBehaviourSys.lua:519>
        libs/Cyan/cyan.lua:69: in function 'call'
        src/misc/unique/gamestate.lua:19: in function 'update'
        [string "boot.lua"]:612: in function <[string "boot.lua"]:594>
        [C]: in function 'xpcall'
This should be fixed as of 16/02/2021



















We cannot construct some entities when the physics world is locked.
That really aint good. Especially given lots of `onDeath` calls are done
during the physics callbacks. I gotta find a real good solution for this
(Maybe `awaitsys`? I dont like it but it may have to be an option)

Error
src/systems/PhysicsSys.lua:176: Box2D assertion failed: IsLocked() == false

Traceback
conf.lua:112: in function 'handler'
[C]: in function 'newBody'
src/systems/PhysicsSys.lua:176: in function 'added'
libs/Cyan/system.lua:249: in function 'add'
libs/Cyan/ent.lua:282: in function '_send_to_systems'
libs/Cyan/ent.lua:154: in function 'add'
src/entities/main/blob.lua:69: in function 'blob'
src/entities/main/bigblob.lua:60: in function 'onDeath'
src/systems/HealthSys.lua:26: in function <src/systems/HealthSys.lua:20>
libs/Cyan/cyan.lua:69: in function 'ccall'
...
src/systems/DetectSys.lua:59: in function <src/systems/DetectSys.lua:55>
libs/Cyan/cyan.lua:69: in function 'ccall'
src/systems/PhysicsSys.lua:66: in function <src/systems/PhysicsSys.lua:52>
[C]: in function 'update'
src/systems/PhysicsSys.lua:129: in function <src/systems/PhysicsSys.lua:128>
libs/Cyan/cyan.lua:69: in function 'call'
src/misc/unique/gamestate.lua:19: in function 'update'
[C]: in function 'xpcall'











This error occured when I exploded a block towards a devil entity
(I think)

Okay, I *THINK* This bug happened when a Node:callback(obj) was invoked on
an object that hadn't ran its first frame. (And thus hadn't had its initial
:choose() function ran -> no `node._path[e]` or `node._index[e]` field granted)
Its fixed for now, I am pretty sure. Pretty sketchy error though, I will never
really know if this was the bug 


Oh no, there has been an Error.
If you can, please contact Oli and show a full screenshot of this error screen. TY!
libs/BehaviourTree/node.lua:161: attempt to index a nil value
Traceback
conf.lua:112: in function 'handler'
libs/BehaviourTree/node.lua:161: in function '_reset'
libs/BehaviourTree/node.lua:249: in function 'call'
src/systems/BehaviourSys.lua:37: in function <src/systems/BehaviourSys.lua:34>
libs/Cyan/cyan.lua:73: in function 'ccall'
src/entities/_EH/init.lua:84: in function 'PC'
src/entities/main/enemy.lua:58: in function 'physics'
src/systems/DetectSys.lua:58: in function <src/systems/DetectSys.lua:54>
libs/Cyan/cyan.lua:73: in function 'ccall'
src/systems/PhysicsSys.lua:45: in function <src/systems/PhysicsSys.lua:31>
[C]: in function 'update'
src/systems/PhysicsSys.lua:110: in function <src/systems/PhysicsSys.lua:109>
libs/Cyan/cyan.lua:73: in function 'call'
src/misc/unique/gamestate.lua:21: in function 'update'
[C]: in function 'xpcall'














rockworms and digging component are just NOT wanting to be correct.
Im starting to wonder if `LOCKON` in MBSys is resetting ent.pos.z position.
====
Do a mutability check, see if the ent.pos tables are memory unique across frames.
print something out every time ent.pos is set to a new vector
(this may not be the bug btw)
in any case, come back with a damn fresh mind, because this bug is a toughey

FIXED: Im so stupid. Was returning in a loop as opposed to `goto continue`























ahhhhhh crap man.
Happened directly after ccall("ratioWin" happened.)
Thiss is gonna be a pain.

ahhh crap man, its error time.
If you can, please contact Oli and show a full screenshot of this screen. TY!
       PLATFORM : Windows
libs/spatial_partition/partition.lua:247: Object disappeared from recorded location in spacial partitioner.
Ensure that your spacial hasher has a cell-size that is greater than the maximum velocity of any hashed object.
Traceback

conf.lua:112: in function 'handler'
[C]: in function 'error'
libs/spatial_partition/partition.lua:247: in function 'getSet'
libs/spatial_partition/partition.lua:129: in function 'updateObj'
libs/spatial_partition/partition.lua:121: in function 'update'
src/systems/PartitionSys.lua:37: in function <src/systems/PartitionSys.lua:36>
libs/Cyan/cyan.lua:73: in function 'call'
src/misc/unique/gamestate.lua:21: in function 'update'
[C]: in function 'xpcall'

VERY VERY GOOD INFORMATION FROM T_DUMP:
Note: the following entity is a portalRing.

object disappeared from partition:
{
  ___mask = 584,
  _cur_portal_period = 0.051206799922511,
  colour = { 0.8, 1, 0.8 },
  draw = {
    h = 16,
    ox = 8,
    oy = 8,
    w = 16
  },
  image = {
    ox = 8,
    oy = 8,
    quad = <userdata 1>
  },
  pos = (+1059.622,+380.543,-30.000)
}

Also, its important to note that `ratioWin`
was called twice before this error

Got the bug!
The portalRing entities were not being deleted.
So when `ccall("purge")` was done, the portalRings still existed, yet were cleared
from the partitioner. (Not the systems tho. ) Thus, TargetSys thought they still
were in the partitioner, and got confused when it couldnt find em




















Error: libs/spatial_partition/partition.lua:247: Object disappeared from recorded location in spacial partitioner.
Ensure that your spacial hasher has a cell-size that is greater than the maximum velocity of any hashed object.

stack traceback:
        [string "boot.lua"]:777: in function <[string "boot.lua"]:773>
        [C]: in function 'error'
        libs/spatial_partition/partition.lua:247: in function 'getSet'
        libs/spatial_partition/partition.lua:142: in function '___rem'
        libs/spatial_partition/partition.lua:151: in function 'setPosition'
        src/systems/PartitionSys.lua:27: in function <src/systems/PartitionSys.lua:17>
        libs/Cyan/cyan.lua:73: in function 'ccall'
        src/systems/MoveSys.lua:90: in function <src/systems/MoveSys.lua:88>
        libs/Cyan/cyan.lua:73: in function 'ccall'
        src/entities/main/bullies/boxbully.lua:90: in function 'onUpdate'
        src/systems/HybridSys.lua:21: in function <src/systems/HybridSys.lua:18>
        libs/Cyan/cyan.lua:73: in function 'call'
        src/misc/unique/gamestate.lua:21: in function 'update'
        [string "boot.lua"]:612: in function <[string "boot.lua"]:594>
        [C]: in function 'xpcall'



This entity is a physics block. Its been splatted, so it wont
be in the physics partition

object disappeared from partition:  
{
  ___mask = 1049592,
  acc = (+0.000,+0.000,+0.000),
  bobbing = {
    magnitude = 0.15,
    oy = -0.3379095390949,
    phase = 3,
    scale = 0.98944032690328,
    value = 0.92960217935523
  },
  collisions = {
    physics = <function 1>
  },
  colour = { 0.88333333333333, 0.83483660130719, 0.055424836601307 },
  friction = {
    amount = 0.9,
    emitter = <userdata 1>,
    on = true,
    required_vel = 2
  },
  grounded = true,
  image = {
    ox = 16,
    oy = 20,
    quad = <userdata 2>
  },
  physics = {
    body = <userdata 3>,
    fixture = <userdata 4>,
    shape = <userdata 5>
  },
  pos = (+1462.335,+955.244,+0.100),
  pushable = false,
  splatted = true,
  vel = (+40.208,+23.497,+0.000)
}















ahhh crap man, its error time.
If you can, please contact Oli and show a full screenshot of this screen. TY!
       PLATFORM : Windows
src/systems/StaticSystems/GenerationSys.lua:412: attempt to compare nil with number

Traceback

conf.lua:112: in function 'handler'
src/systems/StaticSystems/GenerationSys.lua:412: in function 'isGoodFit'
src/systems/StaticSystems/GenerationSys.lua:427: in function 'addPlayer'
src/systems/StaticSystems/GenerationSys.lua:621: in function 'procGenerateWorld'
src/systems/StaticSystems/GenerationSys.lua:657: in function <src/systems/StaticSystems/GenerationSys.lua:635>
libs/Cyan/cyan.lua:73: in function 'ccall'
src/misc/unique/portal_function.lua:18: in function 'func'
src/systems/StaticSystems/AbstractSys.lua:76: in function <src/systems/StaticSystems/AbstractSys.lua:69>
libs/Cyan/cyan.lua:73: in function 'call'
src/misc/unique/gamestate.lua:21: in function 'update'
[C]: in function 'xpcall'

Bug fixed:
If a character was tested that was out of range of the fit,
it needed to return false immediately, else lua errors on comparison with
nil





















ahhh crap man, its error time.
If you can, please contact Oli and show a full screenshot of this screen. TY!
       PLATFORM : Windows
src/systems/MoveSys.lua:42: Attempt to use destroyed body.

Traceback
conf.lua:112: in function 'handler'
[C]: in function 'getLinearVelocity'
src/systems/MoveSys.lua:42: in function 'updateVelo'
src/systems/MoveSys.lua:80: in function <src/systems/MoveSys.lua:78>
libs/Cyan/cyan.lua:73: in function 'call'
src/misc/unique/gamestate.lua:21: in function 'update'
[C]: in function 'xpcall'

Source of bug:
:newWorld is called, but the entities are being produced, and THEN the physics
world is destroyed. This destroys all the bodies in the world as well, and since
we have a bunch of destroyed physics bodies and a bunch of alive entities, 
it clunks out.

ALSO another bug is that ControlSys is signalling lose condition on the one frame 
that the player does not exist




















Enemy count in WinSys is negative. This could be a bug in Cyan.lua...
hopefully not

ahhh crap man, its error time.
If you can, please contact Oli and show a full screenshot of this screen. TY!
       PLATFORM : Windows
src/systems/WinSys.lua:125: wtf man...

Traceback
conf.lua:112: in function 'handler'
[C]: in function 'error'
src/systems/WinSys.lua:125: in function <src/systems/WinSys.lua:123>
libs/Cyan/cyan.lua:73: in function 'call'
src/misc/unique/gamestate.lua:21: in function 'update'
[C]: in function 'xpcall'

TODO
TODO
TODO
TODO!!!!
OKAY, I figured out the bug.
The bug is due to the nature of Cyan.clear and Cyan.flush.
ECS is only flushed on a root ccallback. So when :purge is invoked,
the entities are cleared, but entities remain in the ECS because :purge is not a 
root call, and is instead called from `InteractionSys`. From there, 
:newWorld is called directly. This sets the WinSys enemy counters
to 0 instantly, however, at the next ECS flush, the old entities that are not 
supposed to be apart of the new world are killed, and WinSys thinks
that they were apart of the new world. Since the entities from the previous world
obviously did not contribute to the total enemy counter, this is why enemy count
pops into the negatives. PHEW... ok, now how to fix:

A solution would be to delay the worldgen by a frame and call it at a root call.
This would probably involve some extra functions in Cyan.
A hacky alternative would be to plug the :newWorld call into the next update ccall.
We know that update will always (or should always, TODO add a check for this) be
one level up from the root level.
Oh, damn, nah, just do `ccall("await", {:newWorld}, 0)`, this'll fix it

















